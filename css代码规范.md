# CSS编码技巧
## 减少代码重复

- 代码可维护性最重要的就是尽量减少要编辑的地方
### 鲇鱼效应（一个动，整体动）
####  通过“字号(font-size)”来实现鲇鱼效应，实现一个动，整体动的效果

- 当我们需要放大、缩小一个行内元素或者其他元素的时候，如下，我们可能需要对多处进行更改，这会让人十分头疼。

```css
padding: 6px 16px;
border:1px solid #446d88;
box-shadow:0 1px 5px gray;
color: white;
font-size:20px;
```

- 我们需要将值进行相互依赖，将值之间进行关联。如下，在这个例子中，字高是行高的1.5倍。

```css
font-size : [ 20px | 125%(假设父级字号为 16px)];
line-height:1.5;
```

- 但是这种情况下其他效果并不会变化，因此我们可以改成 **em** 单位，那么所有的值都将根据字号来进行缩放，通过这种方法，我们可以通过字号这个单个样式来控制所有尺寸样式，从而达到鲇鱼效果。
- 顺带一提，通过百分比，我们可以将这一整块的样式跟随着父级字号的变化而变化，从而实现完全一体化变化！

```css
padding: .3em .8em;
border:1px solid #446d88;
box-shadow:0 .05em .25em gray;
color: white;
font-size:125%;
```

- 请注意还有一些长度是绝对值，这些绝对值我们不希望它的粗细收按钮尺寸的影响。

  <!--当使用多个样式进行关联后，em甚至是%都可能导致更为复杂的运算，那么我们可以适当使用rem单位(直接与根级字号(html元素的字号)相关联)-->

#### 通过变亮和变暗的程度来推导颜色的亮色和暗色版本
- 当我们需要修改元素的颜色，我们可能需要修改四条声明(border-color、background、box-shadow和text-shadow)，我们还需要根据亮色和暗色的匹配程度来慢慢修改这四条声明

- 只需要把半透明的黑色或白色叠加在主色调上，即可产生主色调的暗色和颜色变体，这样就可以有效避免多个问题

```css
    padding: .3em .8em;
    border: 1px solid rgba(0, 0, 0, .1);
    background: #00a4ff linear-gradient(hsla(0,0%,100%,.2),transparent);
    border-radius: .2em;
    box-shadow: 0 .05em .25em rgba(0, 0, 0, .5);
    color: white;
    text-shadow: 0 -.05em .05em rgba(0, 0, 0, .5);
```

#### <u>*currentColor*</u> —— 特殊的颜色关键字

- 这个关键字并没有绑定到一个固定的颜色值，，而是一直被解析为color。
- Css3的一个关键字，用于描述当前color的颜色（相当于currentColor 引用 color的属性，随着它变化而变化），如果当前元素css未显式指明color，则继承父元素的颜色

```css
button父容器css
.base-button-container {
    height: 40px;
    width: 98px;
    color: #ffffff;
    font-size: 16px;
    border-radius: 4px;
}
```

```
icon css
width: 16px;
height: 16px;
font-size: 16px;
fill: currentColor;
overflow: hidden;

```

此时由于icon的css上并未显式描述color，所以currentColor的值为父容器设置的color,这样icon的颜色便可以跟着button颜色主题的变化而变化。

#### <u>*inherit*</u> —— 继承

- 在CSS中，子元素会继承了父元素的一些样式属性。能够继承到[子类](https://so.csdn.net/so/search?q=子类&spm=1001.2101.3001.7020)的样式属性非常有限，仅是 `文字、字体`、`颜色`... 子类如果还想继承父类的属性，**可以通过`inherit `强制继承**。

<!--顺带一提，这个关键字对于背景色以及其他同样适用-->

### 字体设计的一点Tip

​		视觉上的错觉在任何形式的视觉设计中都普遍存在，如

- 我们在看到一个完美居中的物体时，会感觉并不居中，如果我们把它的几何学上的中心点稍微往上挪一点，才能取得理想的视觉效果
- 原型的字形与矩形字形相比，需要稍微放大一点，因为我们倾向于把原型感知的比实际尺寸更小一点
- 字母的形状在两端都比较整齐，而顶部和底部则往往参差不齐，为了应对这种方式，我们需要减少顶部和底部的内边距

### 关于响应式网页设计

​		通常我们使用**媒体查询**来修补不同网页**分辨率**下出现的问题，但是，每个媒体查询都会增加成本，这在这之后维护会越来越麻烦

- 媒体查询的断点不应当由具体的设备来决定，而是应该根据设计自身来决定
- 通过**尽量减少代码重复**来解决，这可以一定程度上减轻维护成本
- - 使用百分比长度来代替固定长度，如果实在做不到，那就尝试使用与视口相关的单位`(vw、vh、vmin、vmax`)，他们的值通常被解析为视口宽度或者高度的百分比
  - 当需要在较大分辨率下得到固定宽度时，我们需要使用 `max-width` ，因为它可以适应较小的分辨率，而无需使用媒体查询，`min-width`等同理
  - 不要忘记为替换元素(`img、object、video、iframe`)设定一个max-width,值为100%，这十分重要
  - 当背景图需要铺满整个容器，无论尺寸多少，`background0size:cover`都可以做到 , 但是，带宽并不是无线的，因此在移动网页中通过CSS把大图缩小显示往往显得不太明智
  - 元素以行列式进行布局的时候，让视口的宽度来决定列的数量，弹性布局在这里显得尤为重要(`display:inline-block`)
  - 在使用多列文本时，指定 column-width (列宽) 而不是指定 column-count(列数) ，这样他就可以在较小的屏幕上自动显示为单列布局

### 是否应该使用预处理器？

预处理器使用得当，可以在大型项目中让代码更加灵活，但是，预处理器并不是完美的

- CSS的**文件体积和复杂度**可能会失控
- 后期调试难度会增加 —— 也许我们在开发工具中看到的CSS代码并不是原代码，这些代码往往给我们在阅读上带来不适
- 预处理器在开发过程中引入了一定程度的**延时**，我们不得不等待一段时间才能浏览到代码的效果
- 抽象泄露发着 —— 预处理器是人类写出来的，它们有它们自己的BUG，而我们很少或怀疑预处理器的某个BUG才是CSS出错的幕后元凶
- 预处理器完全不知道怎么完成100% - 50px这样的运算，在真正被渲染之前，百分比是无法被解析的，因此在这些问题上，我们往往趋向于“曲线救国”

# 背景与边框
## 半透明边框
### 难题

- 我们通常会想到给容器设置一层白色背景和一道半透明白色边框，body的背景会从它的半透明边框上透上来，具体如下代码，但是我们发现实际上并不能这样

```css
border: 10px solid hsla(0,0%,100%,.5)
background : white
```

### 解决方法

- 尽管看起来好像一点作用都没有，但我们的边框其实是存在的 —— 默认条件下，背景会延伸到边框所在的区域下层，这个特性就完全打破了我们的想法，让我们编写的border看起来一点用也没有
- 意思是，我们在上面那串`css`钟所做的事情并没有像body的背景从半透明白色边框上透露出来，而是在半透明白色边框上透出了这个容器自己的纯白色背景 —— 等于白给

- 背景与边框第三版开始，我们可以通过background-clip属性来调整上述默认行为，这个值初始值是border-box，意味着背景会被元素的border box所裁剪，如果不希望背景侵入边框所在的范围，我们需要把他的值设为padding-clip，这样浏览器就会用内边距的外延来吧背景剪裁掉

```css
border: 10px solid hsla(0,0%,100%,.5);
background:white;
background-clip:padding-box;
```

<!--顺带附上padding-clip使用规则-->

| border-box  |  背景被裁剪到边框盒。  |
| :---------: | :--------------------: |
| padding-box | 背景被裁剪到内边距框。 |
| content-box | 背景被裁剪到内容框。|

## 多重边框

### 难题

- 我们往往有很多种方式去实现多种边框，如果想方便我们甚至可以利用border或者是border-image或者是嵌套的形式来实行，但是这样往往带来了修改上的不便利，因此这边提供了更好(更统一)的方法来实现

### 解决方案

#### box-shadow 方案

- 我们可以利用box-shadow 来实现 ( 尽管这属性在各种意义上已经被滥用 ) 
  - 它的第四个参数为扩张半径，可以让投影面积变大或变小——一个正值的扩张半径加上两个为0的偏移量以及为0的模糊值，得到的就是一条实现边框 -> 又可以成"投影"
  - 更有意思的是它可以叠加 , 这将非常有利于我们进行统一更改

```css
background: yellowgreen;
box-shadow: 0 0 0 10px #655 ,0 0 0 15px deepplink
```

**注意**

- 投影的行为并不会影响布局，也不会收到box-sizing属性的影响，不过可以通过内边距或者外边距来模拟占据的空间
- 这些假"边框"并不会相应鼠标事件，我们可以给box-shadow加上inset关键字，来使投影绘制在元素的内圈，这样就可以解决（不过如上，需要额外的内边距来腾出足够的空隙）

#### outline方案

- 有些时候，只需要两种边框，就可以先设置常规边框，然后利用outline(描边)属性来产生外层的边框

  - ```css
    background: yellowgrean;
    border: 10px solid #655;
    outline: 5px solid deeppink;
    ```

  - 我们可以通过outline-offset属性来控制元素之间的间距，甚至可以接受负值

**注意**

- 不一定贴合圆角，这被认为是bug，日后可能会改

## 灵活的背景定位

### background-position

- 该属性已经得到扩展，它允许我们指定背景图片距离任意角的偏移量，只要我们在偏移量前面指定关键字，如与右边缘保持20px的偏移量，同时与底边保持10px的偏移量

- 所有浏览器都支持 background-position 属性（需要把 background-attachment 属性设置为 "fixed"，才能保证该属性在 Firefox 和 Opera 中正常工作）。

- ```css
  background-position: right 20px bottom 10px;
  ```

  